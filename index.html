<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>FlexValidator </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="FlexValidator ">
    <meta name="generator" content="docfx 2.40.7.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="flexvalidator">FlexValidator</h1>

<p>A flexible validator made for C#.</p>
<p>See the source code on GitHub: <a href="https://github.com/didii/FlexValidator">https://github.com/didii/FlexValidator</a>.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#flexvalidator">FlexValidator</a><ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#why">Why?</a></li>
<li><a href="#how-to-use-it">How to use it?</a><ul>
<li><a href="#syntax">Syntax</a></li>
<li><a href="#testing">Testing</a></li>
<li><a href="#validators">Validators</a><ul>
<li><a href="#simplevalidator">SimpleValidator</a></li>
<li><a href="#sectionedvalidator">SectionedValidator</a></li>
</ul>
</li>
<li><a href="#utility-methods">Utility methods</a></li>
</ul>
</li>
<li><a href="#the-guid-thing">The GUID thing</a></li>
<li><a href="#todo">Todo</a></li>
</ul>
</li>
</ul>
<h2 id="why">Why?</h2>
<p>I&#39;ve recently been in a project that had a lot of very complex business rules.
It was partly law-based and thus had rules with exceptions and exceptions and exceptions.
We first started using <a href="https://github.com/JeremySkinner/FluentValidation">FluentValidator</a>,
which - don&#39;t get me wrong - is a good framework,
but is not suited for this kind of complex logic with numerous of properties.</p>
<p>The problems we had was:</p>
<ul>
<li>Seperation of concerns (properties that depend on each other need to be in the top-level validator)</li>
<li>Testability (we also need to know if a test was passed)</li>
<li>Complex logic isn&#39;t readable anymore in the Fluent-style</li>
<li>Validations based on multiple properties are weird to write</li>
</ul>
<p>So I came up with another way to write validations where you can simply make use of statements you know: <code>if</code>, <code>else</code>, <code>&amp;&amp;</code>.</p>
<h2 id="how-to-use-it">How to use it?</h2>
<h3 id="syntax">Syntax</h3>
<p>The default syntax is pretty straightforward.</p>
<pre><code class="lang-csharp">private void ValidateName(SomeModel model) {
    //Start a single validation by calling Start and providing an instance of ValidationInfo
    //You are required to give it a GUID as its identifier and a message
    Start(new ValidationInfo(&quot;d4c99639-dd0f-49ba-921f-0c53653b2326&quot;, &quot;Name cannot be null&quot;));

    //Write your validation logic
    if (model.Name == null)
        Fail(); //This fails the last started validation
    else
        Pass(); //This passes the last started validation

    //Complete the validation
    Complete();
    //Using Complete without arguments is recommended, but not required
}
</code></pre><p>The structure is like this:</p>
<ol>
<li>Start the validation by calling <code>Start</code> and provide it with information about the validation.<ol>
<li>If you want more properties, simply extend <code>ValidationInfo</code> and add the properties you need</li>
</ol>
</li>
<li>After <code>Start</code> you can write your custom business logic that leads to calls to <code>Pass</code> or <code>Fail</code>.<ol>
<li>A single validation rule can only fail or pass once. When <code>Fail</code> or <code>Pass</code> is encoutered multiple times, it will throw a <code>InvalidValidatorStateException</code>.</li>
</ol>
</li>
<li>You can complete the rule by calling <code>Complete</code><ol>
<li>It&#39;s recommended to always do this. Calling it without arguments does a check to see if the current rule had a call to <code>Fail</code> or <code>Pass</code>. If not, it will throw a <code>InvalidValidatorStateException</code>.</li>
</ol>
</li>
</ol>
<p>By using the argument in <code>Complete</code> you also simplify the test a bit.</p>
<pre><code class="lang-csharp">private void ValidateName(SomeModel model) {
    Start(new ValidationInfo(&quot;d4c99639-dd0f-49ba-921f-0c53653b2326&quot;, &quot;Name cannot be null&quot;));
    if (model.Name == null)
        Fail();
    Complete(Assume.Pass);
}
</code></pre><p>Now when <code>Complete</code> is encountered and no call to <code>Pass</code> or <code>Fail</code> were made beforehand, it will call <code>Pass</code> for you.
You can also use <code>Assume.Fail</code> to assume the test to be failed if no <code>Pass</code> or <code>Fail</code> was encountered.</p>
<p>Validations can follow each other up as much as you want</p>
<pre><code class="lang-csharp">private void ValidateName(SomeModel model) {
    Start(new ValidationInfo(&quot;d4c99639-dd0f-49ba-921f-0c53653b2326&quot;, &quot;Name cannot be null&quot;));
    if (model.Name == null) {
        Fail();
        //Short-circuit here: other validations don&#39;t matter if Name is null
        return;
    }
    Complete(Assume.Pass);

    Start(new ValidationInfo(&quot;e1410df7-1438-4b5a-a755-1c8657f827a2&quot;, &quot;Name cannot be empty&quot;));
    if (model.Name.Length == 0) {
        Fail();
        //Short-circuit again
        return;
    }
    Complete(Assume.Pass);

    Start(new ValidationInfo(&quot;9aee2017-5c09-485d-8d91-c2d8a102c569&quot;, &quot;Name must start with an alphabetical letter&quot;))
    if (new Regex(@&quot;[a-zA-Z]&quot;).IsMatch(model.name))
        Pass();
    Complete(Assume.Fail);

    //...
}
</code></pre><p>Note that since we write our validations using simple statements, we can short-circuit out a validation.
If <code>Name</code> is <code>null</code>, it does not make sense to still try and run the other validations.
The second validation will fail anyway since this will throw a <code>NullReferenceException</code>.</p>
<h3 id="testing">Testing</h3>
<p>You&#39;re probably also here to know whether or not this makes testing validations easier or not.
Well, according to my findings, it does.
This is why we need the GUID so that a single validation rule can always be identified.
See more below why I chose to use GUIDs.</p>
<p>The test is now pretty easy to write.
In this example I use <code>NUnit</code>, but it can be done with any testing framework.</p>
<pre><code class="lang-csharp">enum Must {
    Pass,
    Fail,
}

[TestCase(Must.Fail, null)]
[TestCase(Must.Pass, &quot;&quot;)]
[TestCase(Must.Pass, &quot;some text&quot;)]
public void Validate_NameCannotBeNull(Must type, string name) {
    //Arrange
    var validator = new MyValidator();
    var model = new SomeModel() {
        Name = name
    }

    //Act
    var result = validator.Validate(model);

    //Assert
    result.Should(type, &quot;d4c99639-dd0f-49ba-921f-0c53653b2326&quot;);
}
</code></pre><p>We have defined an extension method <code>Should</code> on <code>ValidationResult</code> to make our lives easier.
See <a href="https://github.com/didii/FlexValidator/blob/master/FlexValidator.Example.App.Tests/Helpers/ValidationResultExtensions.cs">ValidationResultExtensions.cs</a> for the implemenatation.
In words, it simply checks if <code>result</code> has the given validation (identified by the GUID) in its collection of <code>Fails</code> or <code>Passes</code> and calls <code>Assert.Fail</code> when it&#39;s in the wrong collection or it does not exist.</p>
<p>Take note that the GUID is the same as the first validation we defined above.</p>
<h3 id="validators">Validators</h3>
<p>So, where do you write that code you ask?
I&#39;ve created 2 validators that you can extend to write your logic for you objects.
The <code>SimpleValidator</code> and the <code>SectionedValidator</code>.</p>
<h4 id="simplevalidator">SimpleValidator</h4>
<p>To be used for simple validations where you can test the whole model through.
You don&#39;t need seperate <em>sections</em> to seperate logic for testing.
Ideal for small classes such as a base class that exposes an <code>Id</code>.</p>
<p>To use, simply make a validator that inherits from <code>SimpleValidator</code> and specify (all) the model(s) you want to validate. Then override <code>DoValidate</code> and place your logic in there.</p>
<pre><code class="lang-csharp">class SomeValidator : SimpleValidator&lt;SomeModel&gt; {
    // Override the DoValidate method 
    protected override void DoValidate(SomeModel model) {
        // Use the custom validation logic here
        Start(new ValidationInfo(&quot;someGuid&quot;, &quot;Name cannot be null&quot;));
        if (model.Name == null) {
            Fail();
            return;
        }
        Complete(Assume.Pass);
    }
}
</code></pre><h4 id="sectionedvalidator">SectionedValidator</h4>
<p>To be used for complex models.
You want to seperate logic and isolate certain validation rules so they can be tested properly.
You don&#39;t want the validation of your object to run in one go for testing purposes.</p>
<p>Again, simply make a validator that inherits from <code>SectionedValidator</code> and specify (all) the model(s) you want to validate.</p>
<pre><code class="lang-csharp">class OtherValidator : SectionedValidator&lt;OtherModel&gt; {
    // Declare publicly visible section names to be used in the tests
    public const string IdSection = &quot;Id&quot;;
    public const string SomeSection = &quot;Some&quot;;

    // Constructor where you define all your sections
    public OtherValidator() {
        //Create a validation section to validate only the Id
        Section(IdSection, ValidateId);
        //Create another section to only validate the Name
        Section(SomeSection, ValidateSome);
    }

    private void ValidateId(OtherModel model) {
        Start(new ValidationInfo(&quot;someGuid&quot;, &quot;Id must be greater than 0&quot;));
        if (model.Id &gt; 0)
            Pass();
        Complete(Assume.Fail); 
    }

    private void ValidateName(OtherModel model) {
        Start(new ValidationInfo(&quot;someOtherGuid&quot;, &quot;Name cannot be null or empty&quot;));
        if (string.IsNullOrEmpty(model.Name))
            Fail();
        Complete(Assume.Pass);
    }
}
</code></pre><p>In the constructor we create 2 sections that validate each property of <code>OtherModel</code> seperately.
The end result will be exactly the same: running <code>validator.Validate(model)</code> will still execute each section and all validations will be run.
But for tests it is different.</p>
<p>Here we can call the method <code>ValidateSection</code> instead to make sure only that part is called.
If we have left a <code>throw Exception()</code> in another section, this test won&#39;t be influenced at all.</p>
<pre><code class="lang-csharp">[TestCase(Must.Fail, -5)]
[TestCase(Must.Fail, 0)]
[TestCase(Must.Pass, 9)]
public void Validate_IdSection_IdMustBeGreaterThanZero(Must type, long id) {
    //Arrange
    var validator = new MyValidator();
    var model = new SomeModel() {
        Id = id
    };

    //Act
    var result = validator.ValidateSection(SomeValidator.IdSection, model);

    //Assert
    result.Should(type, &quot;someGuid&quot;);
}
</code></pre><p>Note that internally the sections are stored in a dictionary. This means order is not guaranteed to be reserved when executing <code>Validate</code>. This is intentional and makes it so that your sections need to be entirely independent of each other.</p>
<h3 id="utility-methods">Utility methods</h3>
<p>There are also a couple of utility methods available.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>RunValidator</code></td>
<td>Runs another validator on the model you&#39;ve given it. To be used for nested models.</td>
</tr>
<tr>
<td><code>Passed</code></td>
<td>Give a GUID of a prior test and it will return true if that test passed.</td>
</tr>
<tr>
<td><code>Failed</code></td>
<td>Give a GUID of a prior test and it will return true if that test failed.</td>
</tr>
</tbody>
</table>
<p>Check the API for more info.</p>
<h2 id="the-guid-thing">The GUID thing</h2>
<p>I&#39;ve chosen to work with GUIDs to identify the tests.
There are a couple of reasons why I don&#39;t want this to be different.</p>
<blockquote><p><strong>GUIDs don&#39;t contain human-readable information about the test.</strong></p>
<p>This actively discourages to find a method to identify the tests based on its ID.
It&#39;s a good thing because you don&#39;t ever want to rename the ID.
You write the test once, use it again once in your tests and done.
Never touch the GUID again.</p>
<p>I know at least I have the urge to rename them if I find a better way.</p>
</blockquote>
<blockquote><p><strong>GUIDs are very unique</strong></p>
<p>Grab any online GUID generator, generate 100&#39;s of them and you won&#39;t get a duplicate.
Hence, it&#39;s a good unique identifier.</p>
</blockquote>
<blockquote><p><strong>The Ctrl+F method</strong></p>
<p>Do you see a validation pop up in your frontend where you didn&#39;t expect it?
Make a simple dev tool: e.g. triple click the message to copy the GUID to the clipboard.
Ctrl+F, Ctrl+V and BOOM, you can correct the validation.</p>
<p>No, you can&#39;t always do it with the message because variable data could be shown (<code>$&quot;Last must come after {model.First}&quot;</code>).</p>
</blockquote>
<blockquote><p><strong>But GUIDs are ugly</strong></p>
<p>Well, it&#39;s more ugly to have inconsistent code-names spread throughout your application.</p>
</blockquote>
<h2 id="todo">Todo</h2>
<p>These are things that still need to be added.</p>
<p><strong>Important</strong></p>
<ul>
<li><del>Async support</del><ul>
<li>Still needs to be tested, but the code is there</li>
</ul>
</li>
<li>Pass data to children validators such as their name</li>
</ul>
<p><strong>Less important</strong></p>
<ul>
<li>Custom <code>ValidationInfo</code> object in <code>Start</code> and <code>ValidationResult</code><ul>
<li>For now you can create a class that inherits from <code>ValidationInfo</code> and pass that to <code>Start</code>. You will however have to cast every validation result to your own type afterwards.</li>
</ul>
</li>
<li><del>Make lookups faster (used in <code>Passed</code> and <code>Failed</code>)</del><ul>
<li><del>The <code>List</code> should become a <code>Dictionary</code></del></li>
</ul>
</li>
<li>Make extensibility easier<ul>
<li>Currently, a lot of methods are marked <code>internal</code> which hides implementation details. This makes it easy to properly implement the <code>Simple</code>- and <code>SectionedValidator</code>. But it makes it hard to create custom validators such as the <code>Simple</code>- and <code>SectionedValidator</code>s.</li>
<li>FYI, you can circumvent this currently by creating a project with the name <code>Validator.Extensions</code>. This is however not really ideal.</li>
</ul>
</li>
</ul>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/didii/FlexValidator/blob/master/FlexValidator.Docs/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
